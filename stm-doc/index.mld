{0 qcheck-stm}

{1 Overview: what is [qcheck-stm]?}

[qcheck-stm] is a model based testing framework that builds upon [QCheck].
According to a library description, it generates random programs using the
functionalities of this library and run them, record the results at each steps
of the run, and compare these results with the behaviour of a given pure
(functional) model.

[qcheck-stm] provides two types of tests:

- a sequential one, testing that a sequential run of a generated program is
  correct with respect to the behaviour of the given model
- a parallel one, generating and running a parallel program with two domains
  and testing that the results of the parallel run can be reconciled with a
  sequential execution over the functional model.

{1 Example: how to test a library?}

Let's say we want build a small mutable set library with a constant time
`length` operation. We will be using [qcheck-stm] for testing.

The first version looks like that:

{[
module Lib : sig
  type 'a t
  val empty  : unit -> 'a t
  val mem    : 'a -> 'a t -> bool
  val add    : 'a -> 'a t -> unit
  val length : 'a t -> int
end
= struct
  type 'a t = { 
    mutable content : 'a list;
    mutable length  : int }
  
  let empty () = { content = []; length = 0 }

  let elem a t = List.mem a t.content

  let length t = t.length
  
  let add a t =
    if not (elem a t)
    then begin
      t.content <- a :: t.content;
    end
end
]}

The first thing to do is to provide a description of this library. We call this
description a specification and it takes the form of a module of type
{!module-STM_base.Spec}. In this module, the user describes the library to be
tested, the functional model against which to test it and how to generate
commands from this library.

The model should obviously be simple enough to be obviously correct. The
important thing to keep in mind is that the model doesn't have to have exactly
the same interface as the library to be tested. So no need to have a mutable
set as model, we can use the immutable {!module-Stdlib.Set} library, or build
one if we prefer. Here, we will use the one from the standard library.

We should also choose how to instantiate the type parameter ([Lib.t] is a
container, but if we want to test it, we should precise what type of things it
contains). Let's say it contains [int]s.


{[

module Lib_spec : Spec = struct

  module State = Set.Make (struct type t = int let compare = Int.compare end)

  type sut        = int Lib.t
  let init_sut () = Lib.empty ()
  let cleanup _   = ()

  type cmd =
    | Elem of int
    | Add of int
    | Length [@@deriving show { with_path = false }]

  type state     = State.t
  let init_state = State.empty

  let arb_cmd _state =
    QCheck.make ~print:show_cmd
      (QCheck.Gen.oneof
        [Gen.return Length;
         Gen.map (fun i -> Elem i) Gen.int;
         Gen.map (fun i -> Add i) Gen.int;
        ])

  let next_state cmd state =
    match cmd with 
    | Elem _   -> state 
    | Add i    -> State.add i state 
    | Length   -> state

  let run cmd sut =
    match cmd with 
    | Elem i   -> Res (bool, Lib.elem i sut) 
    | Add i    -> Res (unit, Lib.add i sut)
    | Length   -> Res (int, Lib.length sut)
    
  let precond _ _ = true

  let postcond cmd state res =
    match cmd, res with
    | Elem i,   Res ((Bool,_), b) -> b = State.mem i state
    | Length,   Res ((Int,_), l)  -> l = State.cardinal state
    | Add _,    Res ((Unit,_),_)  -> true
    | _                           -> false
end

]}

In [arb_cmd]'s definition, note [QCheck.make] takes an optional printer.
It is important to provide it so that the test's output is readable. Here, we
use a [ppx_deriver], but you can provide your own printers if you want to.

Now, we are set to run our first [qcheck-stm] tests!

We will begin with some sequential testing. They are declared like that:

{[
module Lib_sequential = STM_sequential.Make(Lib_spec)

let _ = QCheck_runner.run_tests ~verbose:true [Lib_sequential.agree_test ~count:100 ~name:"STM sequential tests"]
]}

Then, add a dune file containing the following stanza:

{[
(executable
  (name mutable_list)
  (libraries qcheck qcheck-stm.sequential)
  (preprocess (pps ppx_deriving.show)))

(rule
  (alias runtest)
  (action (run ./mutable_list.exe)))
]}

Then run the tests:

{[
$ dune runtest
random seed: 449303997
generated error fail pass / total     time test name
[✗]    1    0    1    0 /  100     0.0s STM sequential tests (generating)

--- Failure --------------------------------------------------------------------

Test STM sequential tests failed (4 shrink steps):

[(Add 3591134320860609976); Length]

+++ Messages ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Messages for test STM sequential tests:

  Results incompatible with model

   (Add 3591134320860609976) : ()
   Length : 0
================================================================================
failure (1 tests failed, 0 tests errored, ran 1 tests)
]}

( XXX add someting about shrinking, describe the form of the output)

So, the test are failing. Looking at the output, we see that the [Length]
command returned [0] despite the fact that it has been ran after an addition to
the set. We conclude that ther is something wrong with our implementation of [add].

Indeed, we've forgot to increment the [length] field. That's easily fixed:

{[
module Lib ...

  let add a t =
    if not (elem a t)
    then begin
      t.content <- a :: t.content;
      t.length  <- t.length + 1;
    end

  ...

end
]}

Then, the output looks like that:

{[
$ dune runtest
random seed: 364286126
generated error fail pass / total     time test name
[✓]  100    0    0  100 /  100     0.1s STM sequential tests (generating)
================================================================================
success (ran 1 tests)
]}

We can see that the tests are successful. That means that with the real
behaviour of the one hundred generated programs were consistent with the
functional model we've given.

We've now tested that, when run sequentially, our library behave accordingly to
the functional model we've given. The power of `qcheck-stm` comes from the fact
that we can also test the behaviour of our library when run in a parallel or
concurrent context.

Let's say we want to test our library when it is used with OCaml domains. We
just have to instantiate our specification with another functor:


{[
(* same as before *)

module Lib_domain = STM_domain.Make(Lib_spec)

let _ = QCheck_runner.run_tests ~verbose:true [Lib_domain.agree_test_par ~count:100 ~name:"STM parallel tests"]
]}

In the dune file, we should also update the dependency: [qcheck-stm.sequential]
and [qcheck-stm.domain] are two different libraries.

{[
(executable
  (name mutable_list)
  (modules mutable_list)
  (libraries qcheck qcheck-stm.domain)
  (preprocess (pps ppx_deriving.show)))

(rule
  (alias runtest)
  (action (run ./mutable_list.exe)))
]}

And we are set to run the tests:

{[
$ dune runtest
random seed: 361421041
generated error fail pass / total     time test name
[✗]    3    0    1    2 /  100     2.5s STM sequential tests (shrinking:   17.0007)

--- Failure --------------------------------------------------------------------

Test STM sequential tests failed (17 shrink steps):

                                    |
                                    |
                      .---------------------------.
                      |                           |
          (Add -4579561257187720940)  (Add 2823915666129304696)
                    Length                      Length


+++ Messages ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Messages for test STM sequential tests:

  Results incompatible with linearized model

                                       |
                                       |
                    .------------------------------------.
                    |                                    |
     (Add -4579561257187720940) : ()      (Add 2823915666129304696) : ()
               Length : 1                           Length : 1

================================================================================
failure (1 tests failed, 0 tests errored, ran 1 tests)
]}

Here, the test fails. This means, that even if the library is correct with
respect to the given functional model when run sequentially, the library is not
domain safe.

We can see that the output is a bit different than the one with the failling
sequential test. This is because the generated program is a bit different too.
For testing with using [Domain] or [Thread], [qcheck-stm] generates a triplet
of list of commands: one sequential prefix to bring the system under test in
random state and two parallel (or concurrent) suffixes.

We can see in the minimal counter example proposed by [qcheck-stm] that there
is some concurrent / parallel writes and reads occurring. This is a classical
mistake when writing concurrent / parallel code. 

