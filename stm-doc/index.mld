{0 qcheck-stm}

{1 Overview: what is [qcheck-stm]?}

[qcheck-stm] is a model based testing framework that builds upon [QCheck].
According to a library description, it generates random programs using the
functionalities of this library and run them, record the results at each steps
of the run, and compare these results with the behaviour of a given pure
(functional) model.

[qcheck-stm] provides three types of tests:

- a sequential one, testing that a sequential run of a generated program is
  correct with respect to the behaviour of the given model
- a parallel one, generating and running a parallel program with two domains
  and testing that the results of the parallel run can be reconciled with a
  sequential execution over the functional model.
- a concurrent one, generating and running concurrent programs with two threads
  and testing that the reuslts of the concurrent execution run can be
  reconciled with a sequential execution over the model. Be aware that this
  mode is currently experimental as it does not trigger as many bugs as the
  [domain] mode. This is due to a difference in the frequency of switching
  context between [domain]'s scheduling and [thread]'s one.

{1 Example: how to test a library?}

Let's say we want to build a small mutable set library with a constant time
`length` operation. We will be using [qcheck-stm] for testing.

{2:v1 First version}

The first version looks like that:

{[
module Lib : sig
  type 'a t
  val empty  : unit -> 'a t
  val mem    : 'a -> 'a t -> bool
  val add    : 'a -> 'a t -> unit
  val length : 'a t -> int
end
= struct
  type 'a t = {
    mutable content : 'a list;
    mutable length  : int }

  let empty () = { content = []; length = 0 }

  let mem a t = List.mem a t.content

  let length t = t.length

  let add a t =
    if not (mem a t)
    then begin
      t.content <- a :: t.content;
    end
end
]}

The first thing to do is to provide a description of this library. We call this
description a specification and it takes the form of a module of type
{!module-STM_base.Spec}. In this module, the user describes three things:
{ol
{- the library to be tested,}
{- the functional model against which to test it,}
{- and how to generate commands from this library.}
}

The model should be simple enough to be obviously correct. The important thing
to keep in mind is that the model doesn't have to have exactly the same
interface as the library to be tested. So no need to have a mutable set as
model, we can use the immutable {!module-Stdlib.Set} library, or build one if
we prefer. Here, we will use the one from the standard library.

We should also choose how to instantiate the type parameter ([Lib.t] is a
container, but if we want to test it, we should precise what type of things it
contains). Let's say it contains [int]s.

{[
module Lib_spec : Spec = struct

  module State = Set.Make (struct type t = int let compare = Int.compare end)

  type sut        = int Lib.t
  let init_sut () = Lib.empty ()
  let cleanup _   = ()

  type cmd =
    | Mem of int
    | Add of int
    | Length [@@deriving show { with_path = false }]

  type state     = State.t
  let init_state = State.empty

  let arb_cmd _state =
    QCheck.make ~print:show_cmd
      (QCheck.Gen.oneof
        [Gen.return Length;
         Gen.map (fun i -> Mem i) Gen.int;
         Gen.map (fun i -> Add i) Gen.int;
        ])

  let next_state cmd state =
    match cmd with
    | Mem _  -> state
    | Add i  -> State.add i state
    | Length -> state

  let run cmd sut =
    match cmd with
    | Mem i  -> Res (bool, Lib.mem i sut)
    | Add i  -> Res (unit, Lib.add i sut)
    | Length -> Res (int, Lib.length sut)

  let precond _ _ = true

  let postcond cmd state res =
    match cmd, res with
    | Mem i,  Res ((Bool,_), b) -> b = State.mem i state
    | Length, Res ((Int,_), l)  -> l = State.cardinal state
    | Add _,  Res ((Unit,_),_)  -> true
    | _                           -> false
end
]}

In [arb_cmd]'s definition, note that [QCheck.make] takes an optional printer.
It is important to provide it so that the test's output is readable. Here, we
use a [ppx_deriver], but you can provide your own printers if you want to.

Another remark worth making, is that the [state] argument in the [postcond]
function is the state of the model {i before} running the command (that is
before computing [next_state cmd state]). This will be important when we will
add a {{!section-v5}[remove]} function to our set library.

Now, we are set to run our first [qcheck-stm] tests!

We will begin with some sequential testing. They are declared like that:

{[
module Lib_sequential = STM_sequential.Make(Lib_spec)

let _ = QCheck_runner.run_tests ~verbose:true [Lib_sequential.agree_test ~count:100 ~name:"STM sequential tests"]
]}

Then, add a dune file containing the following stanza:

{[
(executable
  (name mutable_set)
  (libraries qcheck qcheck-stm.sequential)
  (preprocess (pps ppx_deriving.show)))
]}

Then run the tests:

{[
$ dune exec ./mutable_set.exe
random seed: 449303997
generated error fail pass / total     time test name
[✗]    1    0    1    0 /  100     0.0s STM sequential tests (generating)

--- Failure --------------------------------------------------------------------

Test STM sequential tests failed (4 shrink steps):

[(Add 3591134320860609976); Length]

+++ Messages ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Messages for test STM sequential tests:

  Results incompatible with model

   (Add 3591134320860609976) : ()
   Length : 0
================================================================================
failure (1 tests failed, 0 tests errored, ran 1 tests)
]}

Here, the test is failing.

In the case of a failing test, [qcheck-stm] gives the user the counter example
it has found, after some shrinking steps, as it is customary in property based
testing {i à la} QuickCheck. The counter example is a program. It is given
twice. The first time just as a list of calls. The second time, each call is
paired with the the result of the computation.

Looking at the output, we see that [Add 3591134320860609976] returns a [unit],
which is to be expected. But the call to [Length] returns [0] despite the fact
that it has been ran after the [Add]. We conclude that there is something wrong
with our implementation of [add].

Indeed, we've forgotten to increment the [length] field.

{2 Second version}

In the second version, we will fix this problem. This is easily done just by
updating the [length] field when adding an element.

{[
module Lib ...

  let add a t =
    if not (mem a t)
    then begin
      t.content <- a :: t.content;
      t.length  <- t.length + 1;
    end

  ...

end
]}

Then, the output looks like that:

{[
$ dune exec ./mutable_set.exe
random seed: 364286126
generated error fail pass / total     time test name
[✓]  100    0    0  100 /  100     0.1s STM sequential tests (generating)
================================================================================
success (ran 1 tests)
]}

We can see that the tests are successful. That means that the real behaviour of
the one hundred generated programs were consistent with the functional model
we've given.

{2 Third version -- parallel tests}

We've now tested that, when run sequentially, our library behave accordingly to
the functional model we've given. The power of [qcheck-stm] comes from the fact
that we can also test the behaviour of our library when run in a parallel or
concurrent context.

Let's say we want to test our library when it is used with OCaml domains. We
just have to instantiate our specification with another functor:


{[
(* same as before *)

module Lib_domain = STM_domain.Make(Lib_spec)

let _ = QCheck_runner.run_tests ~verbose:true [Lib_domain.agree_test_par ~count:100 ~name:"STM parallel tests"]
]}

In the dune file, we should also update the dependency: [qcheck-stm.sequential]
and [qcheck-stm.domain] are two different libraries. In the same manner, if you
want to test your library with [Thread]s, you'll depends on
[qcheck-stm.thread].

{[
(executable
  (name mutable_set)
  (modules mutable_set)
  (libraries qcheck qcheck-stm.domain)
  (preprocess (pps ppx_deriving.show)))
]}

And we are set to run the tests:

{[
$ dune exec ./mutable_set.exe
random seed: 361421041
generated error fail pass / total     time test name
[✗]    3    0    1    2 /  100     2.5s STM sequential tests (shrinking:   17.0007)

--- Failure --------------------------------------------------------------------

Test STM sequential tests failed (17 shrink steps):

                                    |
                                    |
                      .---------------------------.
                      |                           |
          (Add -4579561257187720940)  (Add 2823915666129304696)
                    Length                      Length


+++ Messages ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Messages for test STM sequential tests:

  Results incompatible with linearized model

                                       |
                                       |
                    .------------------------------------.
                    |                                    |
     (Add -4579561257187720940) : ()      (Add 2823915666129304696) : ()
               Length : 1                           Length : 1

================================================================================
failure (1 tests failed, 0 tests errored, ran 1 tests)
]}

Here, the test fails again. This means, that even if the library is correct with
respect to the given functional model when run sequentially, the library is not
domain safe.

We can see that the output is a bit different than the one with the failling
sequential test. This is because the generated programs are a bit different
too. For testing with using [Domain] or [Thread], [qcheck-stm] generates a
triplet of list of calls: one sequential prefix to bring the system under
test in a random state and two parallel (or concurrent) suffixes.

We can see in the minimal counter example proposed by [qcheck-stm] that there
is some concurrent / parallel writes and reads occurring. This is a classical
mistake when writing concurrent / parallel code.

{2 Fourth version}

Let's fix that by putting some lock on every operation. This will end up being
quite slow. In a real life program, you'll probably want to be a bit smarter
than that.

{[
open QCheck
open STM_base

module Lib : sig
  type 'a t
  val empty  : unit -> 'a t
  val mem    : 'a -> 'a t -> bool
  val add    : 'a -> 'a t -> unit
  val length : 'a t -> int
end
= struct
  type 'a t = {
    mutable content : 'a list;
    mutable length  : int;
    mutex           : Mutex.t}

  let empty () = { content = []; length = 0; mutex = Mutex.create () }

  let mem_non_lock a t = List.mem a t.content

  let mem a t =
    Mutex.lock t.mutex;
    let b = mem_non_lock a t in
    Mutex.unlock t.mutex;
    b

  let add a t =
    Mutex.lock t.mutex;
    if not (mem_non_lock a t)
    then begin
      t.content <- a :: t.content;
      t.length  <- t.length + 1;
    end;
    Mutex.unlock t.mutex

  let length t =
    Mutex.lock t.mutex;
    let l = t.length in
    Mutex.unlock t.mutex;
    l
end
]}

The specification is exactly the same. So we can directly run the test.

{[
$ dune exec ./mutable_set.exe
random seed: 289882953
generated error fail pass / total     time test name
[✓]  100    0    0  100 /  100    37.8s STM parallel tests
================================================================================
success (ran 1 tests)
]}

This time, the test succeed!

{2 Fifth version -- adding a [remove] function}

Now that our implementation is domain safe, let's add a new feature: a [remove]
function. Here, we need to be careful about the generation of the argument
given to the [remove] function in the tests.

The [remove] function is interesting because we want to test what's going on
when we remove an element that has been put in the list and when we try to
remove one that is not in the list. In order to do so, we need to be careful
about the argument that will be generated and given to the [Remove] command in
the specification. Fortunately, the [arb_cmd] function used to describe how to
generate commands takes a [state] as argument. So we can make the generation of
commands (function with there arguments) depends on the state of the model.
This will help to skew the distribution of the generated programs to include
more removal of elements that are indeed in the set.

We will also make the [remove] function return an [int option]. If the given
element was contained in the set, then it will be removed and return in a
[Some]. And if it was not in the set, then the function will return [None].

Let's say we've added the [remove] function in the implementation and the specification.
We can update the [arb_cmd] function as below:

{[
let arb_cmd state =
  let gen =
    if State.is_empty state
    then Gen.int
    else Gen.(oneof [oneofl (State.to_seq state |> List.of_seq); int])
  in
  QCheck.make ~print:show_cmd
    (QCheck.Gen.oneof
      [Gen.return Length;
       Gen.map (fun i -> Mem i) Gen.int;
       Gen.map (fun i -> Add i) Gen.int;
       Gen.map (fun i -> Remove i) gen;
      ])
]}

Here, we make the generation of the argument given to [remove] depend on the
[state]: either pick an element that is in the set or use the [QCheck.Gen.int]
generator. We could also use the [QCheck.Gen.frequency] instead of the
[QCheck.Gen.oneof] to give a different weight to the two generators and skew
the distribution in favor of one of them.

Now, let's take a look at the [postcond] function. As noted above, the [state]
parameter of the [postcond] function is the [model] state {i before} the
execution of the [cmd] (that is before the computation of [next_state cmd
state]). This is usefull because we can now check the result of the [remove]
function is correct according to the model's [state].

{[
let postcond cmd state res =
  match cmd, res with
  | Mem i,    Res ((Bool,_), b)            -> b = State.mem i state
  | Length,   Res ((Int,_), l)             -> l = State.cardinal state
  | Add _,    Res ((Unit,_),_)             -> true
  | Remove i, Res ((Option Int ,_),Some x) -> State.mem i state && i = x
  | Remove i, Res ((Option Int,_),None)    -> not (State.mem i state)
  | _                                      -> false
]}

Here, we can specify that when running [Remove i] returns [Some x], then [i]
should be an element of [state] and that [x] should be equal to [i].  On the
other hand, if it returns [None], then [i] should not be an element of [state].

{1 Content}

- {!module-STM_base}.
- {!module-STM_domain} exposes a functor that allows to test a library in parallel (with domains).
- {!module-STM_thread} exposes a functor that allows to test a library in concurrency (with threads).
- {!module-STM_sequential} exposes a functor that allow to test a library sequentially.


